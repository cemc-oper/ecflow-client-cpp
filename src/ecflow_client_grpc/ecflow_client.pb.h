// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecflow_client.proto

#ifndef PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
#define PROTOBUF_INCLUDED_ecflow_5fclient_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ecflow_5fclient_2eproto 

namespace protobuf_ecflow_5fclient_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ecflow_5fclient_2eproto
namespace ecflow_client {
class NodeRequest;
class NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class NodeResponse;
class NodeResponseDefaultTypeInternal;
extern NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
class ResponseStatus;
class ResponseStatusDefaultTypeInternal;
extern ResponseStatusDefaultTypeInternal _ResponseStatus_default_instance_;
class StatusRecordsResponse;
class StatusRecordsResponseDefaultTypeInternal;
extern StatusRecordsResponseDefaultTypeInternal _StatusRecordsResponse_default_instance_;
class StatusRecordsResponse_StatusMapEntry_DoNotUse;
class StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal;
extern StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal _StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_;
class StatusRequest;
class StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace ecflow_client
namespace google {
namespace protobuf {
template<> ::ecflow_client::NodeRequest* Arena::CreateMaybeMessage<::ecflow_client::NodeRequest>(Arena*);
template<> ::ecflow_client::NodeResponse* Arena::CreateMaybeMessage<::ecflow_client::NodeResponse>(Arena*);
template<> ::ecflow_client::ResponseStatus* Arena::CreateMaybeMessage<::ecflow_client::ResponseStatus>(Arena*);
template<> ::ecflow_client::StatusRecordsResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse>(Arena*);
template<> ::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse>(Arena*);
template<> ::ecflow_client::StatusRequest* Arena::CreateMaybeMessage<::ecflow_client::StatusRequest>(Arena*);
template<> ::ecflow_client::StatusResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ecflow_client {

// ===================================================================

class ResponseStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.ResponseStatus) */ {
 public:
  ResponseStatus();
  virtual ~ResponseStatus();

  ResponseStatus(const ResponseStatus& from);

  inline ResponseStatus& operator=(const ResponseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStatus(ResponseStatus&& from) noexcept
    : ResponseStatus() {
    *this = ::std::move(from);
  }

  inline ResponseStatus& operator=(ResponseStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStatus* internal_default_instance() {
    return reinterpret_cast<const ResponseStatus*>(
               &_ResponseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ResponseStatus* other);
  friend void swap(ResponseStatus& a, ResponseStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStatus* New() const final {
    return CreateMaybeMessage<ResponseStatus>(NULL);
  }

  ResponseStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStatus& from);
  void MergeFrom(const ResponseStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_string = 2;
  void clear_error_string();
  static const int kErrorStringFieldNumber = 2;
  const ::std::string& error_string() const;
  void set_error_string(const ::std::string& value);
  #if LANG_CXX11
  void set_error_string(::std::string&& value);
  #endif
  void set_error_string(const char* value);
  void set_error_string(const char* value, size_t size);
  ::std::string* mutable_error_string();
  ::std::string* release_error_string();
  void set_allocated_error_string(::std::string* error_string);

  // bool has_error = 1;
  void clear_has_error();
  static const int kHasErrorFieldNumber = 1;
  bool has_error() const;
  void set_has_error(bool value);

  // @@protoc_insertion_point(class_scope:ecflow_client.ResponseStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_string_;
  bool has_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRequest) */ {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(StatusRequest* other);
  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const final {
    return CreateMaybeMessage<StatusRequest>(NULL);
  }

  StatusRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string host = 3;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusRecordsResponse_StatusMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StatusRecordsResponse_StatusMapEntry_DoNotUse();
  StatusRecordsResponse_StatusMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StatusRecordsResponse_StatusMapEntry_DoNotUse& other);
  static const StatusRecordsResponse_StatusMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StatusRecordsResponse_StatusMapEntry_DoNotUse*>(&_StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StatusRecordsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRecordsResponse) */ {
 public:
  StatusRecordsResponse();
  virtual ~StatusRecordsResponse();

  StatusRecordsResponse(const StatusRecordsResponse& from);

  inline StatusRecordsResponse& operator=(const StatusRecordsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusRecordsResponse(StatusRecordsResponse&& from) noexcept
    : StatusRecordsResponse() {
    *this = ::std::move(from);
  }

  inline StatusRecordsResponse& operator=(StatusRecordsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRecordsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRecordsResponse* internal_default_instance() {
    return reinterpret_cast<const StatusRecordsResponse*>(
               &_StatusRecordsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StatusRecordsResponse* other);
  friend void swap(StatusRecordsResponse& a, StatusRecordsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusRecordsResponse* New() const final {
    return CreateMaybeMessage<StatusRecordsResponse>(NULL);
  }

  StatusRecordsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusRecordsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusRecordsResponse& from);
  void MergeFrom(const StatusRecordsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRecordsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> status_map = 4;
  int status_map_size() const;
  void clear_status_map();
  static const int kStatusMapFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      status_map() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_status_map();

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  void clear_response_status();
  static const int kResponseStatusFieldNumber = 5;
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  public:
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  static const int kCollectedTimestampFieldNumber = 3;
  ::google::protobuf::int64 collected_timestamp() const;
  void set_collected_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRecordsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StatusRecordsResponse_StatusMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > status_map_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::ecflow_client::ResponseStatus* response_status_;
  ::google::protobuf::int64 collected_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(StatusResponse* other);
  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(NULL);
  }

  StatusResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  void clear_response_status();
  static const int kResponseStatusFieldNumber = 5;
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  public:
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  static const int kCollectedTimestampFieldNumber = 3;
  ::google::protobuf::int64 collected_timestamp() const;
  void set_collected_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::ecflow_client::ResponseStatus* response_status_;
  ::google::protobuf::int64 collected_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.NodeRequest) */ {
 public:
  NodeRequest();
  virtual ~NodeRequest();

  NodeRequest(const NodeRequest& from);

  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeRequest(NodeRequest&& from) noexcept
    : NodeRequest() {
    *this = ::std::move(from);
  }

  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
               &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NodeRequest* other);
  friend void swap(NodeRequest& a, NodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeRequest* New() const final {
    return CreateMaybeMessage<NodeRequest>(NULL);
  }

  NodeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeRequest& from);
  void MergeFrom(const NodeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string host = 3;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:ecflow_client.NodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.NodeResponse) */ {
 public:
  NodeResponse();
  virtual ~NodeResponse();

  NodeResponse(const NodeResponse& from);

  inline NodeResponse& operator=(const NodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeResponse(NodeResponse&& from) noexcept
    : NodeResponse() {
    *this = ::std::move(from);
  }

  inline NodeResponse& operator=(NodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeResponse*>(
               &_NodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NodeResponse* other);
  friend void swap(NodeResponse& a, NodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeResponse* New() const final {
    return CreateMaybeMessage<NodeResponse>(NULL);
  }

  NodeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeResponse& from);
  void MergeFrom(const NodeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string path = 3;
  void clear_path();
  static const int kPathFieldNumber = 3;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string node = 4;
  void clear_node();
  static const int kNodeFieldNumber = 4;
  const ::std::string& node() const;
  void set_node(const ::std::string& value);
  #if LANG_CXX11
  void set_node(::std::string&& value);
  #endif
  void set_node(const char* value);
  void set_node(const char* value, size_t size);
  ::std::string* mutable_node();
  ::std::string* release_node();
  void set_allocated_node(::std::string* node);

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  void clear_response_status();
  static const int kResponseStatusFieldNumber = 5;
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  public:
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);

  // @@protoc_insertion_point(class_scope:ecflow_client.NodeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr node_;
  ::ecflow_client::ResponseStatus* response_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResponseStatus

// bool has_error = 1;
inline void ResponseStatus::clear_has_error() {
  has_error_ = false;
}
inline bool ResponseStatus::has_error() const {
  // @@protoc_insertion_point(field_get:ecflow_client.ResponseStatus.has_error)
  return has_error_;
}
inline void ResponseStatus::set_has_error(bool value) {
  
  has_error_ = value;
  // @@protoc_insertion_point(field_set:ecflow_client.ResponseStatus.has_error)
}

// string error_string = 2;
inline void ResponseStatus::clear_error_string() {
  error_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseStatus::error_string() const {
  // @@protoc_insertion_point(field_get:ecflow_client.ResponseStatus.error_string)
  return error_string_.GetNoArena();
}
inline void ResponseStatus::set_error_string(const ::std::string& value) {
  
  error_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.ResponseStatus.error_string)
}
#if LANG_CXX11
inline void ResponseStatus::set_error_string(::std::string&& value) {
  
  error_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.ResponseStatus.error_string)
}
#endif
inline void ResponseStatus::set_error_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.ResponseStatus.error_string)
}
inline void ResponseStatus::set_error_string(const char* value, size_t size) {
  
  error_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.ResponseStatus.error_string)
}
inline ::std::string* ResponseStatus::mutable_error_string() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.ResponseStatus.error_string)
  return error_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseStatus::release_error_string() {
  // @@protoc_insertion_point(field_release:ecflow_client.ResponseStatus.error_string)
  
  return error_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStatus::set_allocated_error_string(::std::string* error_string) {
  if (error_string != NULL) {
    
  } else {
    
  }
  error_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_string);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.ResponseStatus.error_string)
}

// -------------------------------------------------------------------

// StatusRequest

// string owner = 1;
inline void StatusRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.owner)
  return owner_.GetNoArena();
}
inline void StatusRequest::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.owner)
}
#if LANG_CXX11
inline void StatusRequest::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.owner)
}
#endif
inline void StatusRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.owner)
}
inline void StatusRequest::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.owner)
}
inline ::std::string* StatusRequest::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.owner)
}

// string repo = 2;
inline void StatusRequest::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.repo)
  return repo_.GetNoArena();
}
inline void StatusRequest::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.repo)
}
#if LANG_CXX11
inline void StatusRequest::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.repo)
}
#endif
inline void StatusRequest::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.repo)
}
inline void StatusRequest::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.repo)
}
inline ::std::string* StatusRequest::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.repo)
}

// string host = 3;
inline void StatusRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::host() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.host)
  return host_.GetNoArena();
}
inline void StatusRequest::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.host)
}
#if LANG_CXX11
inline void StatusRequest::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.host)
}
#endif
inline void StatusRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.host)
}
inline void StatusRequest::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.host)
}
inline ::std::string* StatusRequest::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_host() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.host)
}

// string port = 4;
inline void StatusRequest::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::port() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.port)
  return port_.GetNoArena();
}
inline void StatusRequest::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.port)
}
#if LANG_CXX11
inline void StatusRequest::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.port)
}
#endif
inline void StatusRequest::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.port)
}
inline void StatusRequest::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.port)
}
inline ::std::string* StatusRequest::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_port() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.port)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StatusRecordsResponse

// string owner = 1;
inline void StatusRecordsResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRecordsResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.owner)
  return owner_.GetNoArena();
}
inline void StatusRecordsResponse::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.owner)
}
#if LANG_CXX11
inline void StatusRecordsResponse::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.owner)
}
#endif
inline void StatusRecordsResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.owner)
}
inline void StatusRecordsResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.owner)
}
inline ::std::string* StatusRecordsResponse::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRecordsResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.owner)
}

// string repo = 2;
inline void StatusRecordsResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRecordsResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.repo)
  return repo_.GetNoArena();
}
inline void StatusRecordsResponse::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.repo)
}
#if LANG_CXX11
inline void StatusRecordsResponse::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.repo)
}
#endif
inline void StatusRecordsResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.repo)
}
inline void StatusRecordsResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.repo)
}
inline ::std::string* StatusRecordsResponse::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRecordsResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusRecordsResponse::clear_collected_timestamp() {
  collected_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StatusRecordsResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.collected_timestamp)
  return collected_timestamp_;
}
inline void StatusRecordsResponse::set_collected_timestamp(::google::protobuf::int64 value) {
  
  collected_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.collected_timestamp)
}

// map<string, string> status_map = 4;
inline int StatusRecordsResponse::status_map_size() const {
  return status_map_.size();
}
inline void StatusRecordsResponse::clear_status_map() {
  status_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
StatusRecordsResponse::status_map() const {
  // @@protoc_insertion_point(field_map:ecflow_client.StatusRecordsResponse.status_map)
  return status_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
StatusRecordsResponse::mutable_status_map() {
  // @@protoc_insertion_point(field_mutable_map:ecflow_client.StatusRecordsResponse.status_map)
  return status_map_.MutableMap();
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool StatusRecordsResponse::has_response_status() const {
  return this != internal_default_instance() && response_status_ != NULL;
}
inline void StatusRecordsResponse::clear_response_status() {
  if (GetArenaNoVirtual() == NULL && response_status_ != NULL) {
    delete response_status_;
  }
  response_status_ = NULL;
}
inline const ::ecflow_client::ResponseStatus& StatusRecordsResponse::_internal_response_status() const {
  return *response_status_;
}
inline const ::ecflow_client::ResponseStatus& StatusRecordsResponse::response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.response_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline ::ecflow_client::ResponseStatus* StatusRecordsResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = NULL;
  return temp;
}
inline ::ecflow_client::ResponseStatus* StatusRecordsResponse::mutable_response_status() {
  
  if (response_status_ == NULL) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.response_status)
  return response_status_;
}
inline void StatusRecordsResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_status_;
  }
  if (response_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.response_status)
}

// -------------------------------------------------------------------

// StatusResponse

// string owner = 1;
inline void StatusResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.owner)
  return owner_.GetNoArena();
}
inline void StatusResponse::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.owner)
}
#if LANG_CXX11
inline void StatusResponse::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.owner)
}
#endif
inline void StatusResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.owner)
}
inline void StatusResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.owner)
}
inline ::std::string* StatusResponse::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.owner)
}

// string repo = 2;
inline void StatusResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.repo)
  return repo_.GetNoArena();
}
inline void StatusResponse::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.repo)
}
#if LANG_CXX11
inline void StatusResponse::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.repo)
}
#endif
inline void StatusResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.repo)
}
inline void StatusResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.repo)
}
inline ::std::string* StatusResponse::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusResponse::clear_collected_timestamp() {
  collected_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StatusResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.collected_timestamp)
  return collected_timestamp_;
}
inline void StatusResponse::set_collected_timestamp(::google::protobuf::int64 value) {
  
  collected_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.collected_timestamp)
}

// string status = 4;
inline void StatusResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.status)
  return status_.GetNoArena();
}
inline void StatusResponse::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.status)
}
#if LANG_CXX11
inline void StatusResponse::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.status)
}
#endif
inline void StatusResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.status)
}
inline void StatusResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.status)
}
inline ::std::string* StatusResponse::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.status)
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool StatusResponse::has_response_status() const {
  return this != internal_default_instance() && response_status_ != NULL;
}
inline void StatusResponse::clear_response_status() {
  if (GetArenaNoVirtual() == NULL && response_status_ != NULL) {
    delete response_status_;
  }
  response_status_ = NULL;
}
inline const ::ecflow_client::ResponseStatus& StatusResponse::_internal_response_status() const {
  return *response_status_;
}
inline const ::ecflow_client::ResponseStatus& StatusResponse::response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.response_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline ::ecflow_client::ResponseStatus* StatusResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = NULL;
  return temp;
}
inline ::ecflow_client::ResponseStatus* StatusResponse::mutable_response_status() {
  
  if (response_status_ == NULL) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.response_status)
  return response_status_;
}
inline void StatusResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_status_;
  }
  if (response_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.response_status)
}

// -------------------------------------------------------------------

// NodeRequest

// string owner = 1;
inline void NodeRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRequest::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.owner)
  return owner_.GetNoArena();
}
inline void NodeRequest::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.owner)
}
#if LANG_CXX11
inline void NodeRequest::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.owner)
}
#endif
inline void NodeRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.owner)
}
inline void NodeRequest::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.owner)
}
inline ::std::string* NodeRequest::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRequest::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.owner)
}

// string repo = 2;
inline void NodeRequest::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRequest::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.repo)
  return repo_.GetNoArena();
}
inline void NodeRequest::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.repo)
}
#if LANG_CXX11
inline void NodeRequest::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.repo)
}
#endif
inline void NodeRequest::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.repo)
}
inline void NodeRequest::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.repo)
}
inline ::std::string* NodeRequest::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRequest::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.repo)
}

// string host = 3;
inline void NodeRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRequest::host() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.host)
  return host_.GetNoArena();
}
inline void NodeRequest::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.host)
}
#if LANG_CXX11
inline void NodeRequest::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.host)
}
#endif
inline void NodeRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.host)
}
inline void NodeRequest::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.host)
}
inline ::std::string* NodeRequest::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRequest::release_host() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.host)
}

// string port = 4;
inline void NodeRequest::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRequest::port() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.port)
  return port_.GetNoArena();
}
inline void NodeRequest::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.port)
}
#if LANG_CXX11
inline void NodeRequest::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.port)
}
#endif
inline void NodeRequest::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.port)
}
inline void NodeRequest::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.port)
}
inline ::std::string* NodeRequest::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRequest::release_port() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.port)
}

// string path = 5;
inline void NodeRequest::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRequest::path() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.path)
  return path_.GetNoArena();
}
inline void NodeRequest::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.path)
}
#if LANG_CXX11
inline void NodeRequest::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.path)
}
#endif
inline void NodeRequest::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.path)
}
inline void NodeRequest::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.path)
}
inline ::std::string* NodeRequest::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRequest::release_path() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.path)
}

// -------------------------------------------------------------------

// NodeResponse

// string owner = 1;
inline void NodeResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.owner)
  return owner_.GetNoArena();
}
inline void NodeResponse::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.owner)
}
#if LANG_CXX11
inline void NodeResponse::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.owner)
}
#endif
inline void NodeResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.owner)
}
inline void NodeResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.owner)
}
inline ::std::string* NodeResponse::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.owner)
}

// string repo = 2;
inline void NodeResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.repo)
  return repo_.GetNoArena();
}
inline void NodeResponse::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.repo)
}
#if LANG_CXX11
inline void NodeResponse::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.repo)
}
#endif
inline void NodeResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.repo)
}
inline void NodeResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.repo)
}
inline ::std::string* NodeResponse::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.repo)
}

// string path = 3;
inline void NodeResponse::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeResponse::path() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.path)
  return path_.GetNoArena();
}
inline void NodeResponse::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.path)
}
#if LANG_CXX11
inline void NodeResponse::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.path)
}
#endif
inline void NodeResponse::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.path)
}
inline void NodeResponse::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.path)
}
inline ::std::string* NodeResponse::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeResponse::release_path() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.path)
}

// string node = 4;
inline void NodeResponse::clear_node() {
  node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeResponse::node() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.node)
  return node_.GetNoArena();
}
inline void NodeResponse::set_node(const ::std::string& value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.node)
}
#if LANG_CXX11
inline void NodeResponse::set_node(::std::string&& value) {
  
  node_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.node)
}
#endif
inline void NodeResponse::set_node(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.node)
}
inline void NodeResponse::set_node(const char* value, size_t size) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.node)
}
inline ::std::string* NodeResponse::mutable_node() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.node)
  return node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeResponse::release_node() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.node)
  
  return node_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_node(::std::string* node) {
  if (node != NULL) {
    
  } else {
    
  }
  node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.node)
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool NodeResponse::has_response_status() const {
  return this != internal_default_instance() && response_status_ != NULL;
}
inline void NodeResponse::clear_response_status() {
  if (GetArenaNoVirtual() == NULL && response_status_ != NULL) {
    delete response_status_;
  }
  response_status_ = NULL;
}
inline const ::ecflow_client::ResponseStatus& NodeResponse::_internal_response_status() const {
  return *response_status_;
}
inline const ::ecflow_client::ResponseStatus& NodeResponse::response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.response_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline ::ecflow_client::ResponseStatus* NodeResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = NULL;
  return temp;
}
inline ::ecflow_client::ResponseStatus* NodeResponse::mutable_response_status() {
  
  if (response_status_ == NULL) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.response_status)
  return response_status_;
}
inline void NodeResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_status_;
  }
  if (response_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.response_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ecflow_client

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
