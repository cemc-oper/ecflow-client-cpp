// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecflow_client.proto

#ifndef PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
#define PROTOBUF_INCLUDED_ecflow_5fclient_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ecflow_5fclient_2eproto 

namespace protobuf_ecflow_5fclient_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ecflow_5fclient_2eproto
namespace ecflow_client {
class StatusRecordsResponse;
class StatusRecordsResponseDefaultTypeInternal;
extern StatusRecordsResponseDefaultTypeInternal _StatusRecordsResponse_default_instance_;
class StatusRecordsResponse_StatusMapEntry_DoNotUse;
class StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal;
extern StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal _StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_;
class StatusRequest;
class StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace ecflow_client
namespace google {
namespace protobuf {
template<> ::ecflow_client::StatusRecordsResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse>(Arena*);
template<> ::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse>(Arena*);
template<> ::ecflow_client::StatusRequest* Arena::CreateMaybeMessage<::ecflow_client::StatusRequest>(Arena*);
template<> ::ecflow_client::StatusResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ecflow_client {

// ===================================================================

class StatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRequest) */ {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StatusRequest* other);
  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const final {
    return CreateMaybeMessage<StatusRequest>(NULL);
  }

  StatusRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string host = 3;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusRecordsResponse_StatusMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StatusRecordsResponse_StatusMapEntry_DoNotUse();
  StatusRecordsResponse_StatusMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StatusRecordsResponse_StatusMapEntry_DoNotUse& other);
  static const StatusRecordsResponse_StatusMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StatusRecordsResponse_StatusMapEntry_DoNotUse*>(&_StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StatusRecordsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRecordsResponse) */ {
 public:
  StatusRecordsResponse();
  virtual ~StatusRecordsResponse();

  StatusRecordsResponse(const StatusRecordsResponse& from);

  inline StatusRecordsResponse& operator=(const StatusRecordsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusRecordsResponse(StatusRecordsResponse&& from) noexcept
    : StatusRecordsResponse() {
    *this = ::std::move(from);
  }

  inline StatusRecordsResponse& operator=(StatusRecordsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRecordsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRecordsResponse* internal_default_instance() {
    return reinterpret_cast<const StatusRecordsResponse*>(
               &_StatusRecordsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(StatusRecordsResponse* other);
  friend void swap(StatusRecordsResponse& a, StatusRecordsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusRecordsResponse* New() const final {
    return CreateMaybeMessage<StatusRecordsResponse>(NULL);
  }

  StatusRecordsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusRecordsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusRecordsResponse& from);
  void MergeFrom(const StatusRecordsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRecordsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> status_map = 4;
  int status_map_size() const;
  void clear_status_map();
  static const int kStatusMapFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      status_map() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_status_map();

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  static const int kCollectedTimestampFieldNumber = 3;
  ::google::protobuf::int64 collected_timestamp() const;
  void set_collected_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRecordsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StatusRecordsResponse_StatusMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > status_map_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::int64 collected_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StatusResponse* other);
  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(NULL);
  }

  StatusResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  #if LANG_CXX11
  void set_owner(::std::string&& value);
  #endif
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // string repo = 2;
  void clear_repo();
  static const int kRepoFieldNumber = 2;
  const ::std::string& repo() const;
  void set_repo(const ::std::string& value);
  #if LANG_CXX11
  void set_repo(::std::string&& value);
  #endif
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  ::std::string* mutable_repo();
  ::std::string* release_repo();
  void set_allocated_repo(::std::string* repo);

  // string status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  static const int kCollectedTimestampFieldNumber = 3;
  ::google::protobuf::int64 collected_timestamp() const;
  void set_collected_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  ::google::protobuf::internal::ArenaStringPtr repo_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int64 collected_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ecflow_5fclient_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StatusRequest

// string owner = 1;
inline void StatusRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.owner)
  return owner_.GetNoArena();
}
inline void StatusRequest::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.owner)
}
#if LANG_CXX11
inline void StatusRequest::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.owner)
}
#endif
inline void StatusRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.owner)
}
inline void StatusRequest::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.owner)
}
inline ::std::string* StatusRequest::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.owner)
}

// string repo = 2;
inline void StatusRequest::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.repo)
  return repo_.GetNoArena();
}
inline void StatusRequest::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.repo)
}
#if LANG_CXX11
inline void StatusRequest::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.repo)
}
#endif
inline void StatusRequest::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.repo)
}
inline void StatusRequest::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.repo)
}
inline ::std::string* StatusRequest::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.repo)
}

// string host = 3;
inline void StatusRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::host() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.host)
  return host_.GetNoArena();
}
inline void StatusRequest::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.host)
}
#if LANG_CXX11
inline void StatusRequest::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.host)
}
#endif
inline void StatusRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.host)
}
inline void StatusRequest::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.host)
}
inline ::std::string* StatusRequest::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_host() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.host)
}

// string port = 4;
inline void StatusRequest::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::port() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.port)
  return port_.GetNoArena();
}
inline void StatusRequest::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.port)
}
#if LANG_CXX11
inline void StatusRequest::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.port)
}
#endif
inline void StatusRequest::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.port)
}
inline void StatusRequest::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.port)
}
inline ::std::string* StatusRequest::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_port() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.port)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StatusRecordsResponse

// string owner = 1;
inline void StatusRecordsResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRecordsResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.owner)
  return owner_.GetNoArena();
}
inline void StatusRecordsResponse::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.owner)
}
#if LANG_CXX11
inline void StatusRecordsResponse::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.owner)
}
#endif
inline void StatusRecordsResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.owner)
}
inline void StatusRecordsResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.owner)
}
inline ::std::string* StatusRecordsResponse::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRecordsResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.owner)
}

// string repo = 2;
inline void StatusRecordsResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRecordsResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.repo)
  return repo_.GetNoArena();
}
inline void StatusRecordsResponse::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.repo)
}
#if LANG_CXX11
inline void StatusRecordsResponse::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.repo)
}
#endif
inline void StatusRecordsResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.repo)
}
inline void StatusRecordsResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.repo)
}
inline ::std::string* StatusRecordsResponse::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRecordsResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusRecordsResponse::clear_collected_timestamp() {
  collected_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StatusRecordsResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.collected_timestamp)
  return collected_timestamp_;
}
inline void StatusRecordsResponse::set_collected_timestamp(::google::protobuf::int64 value) {
  
  collected_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.collected_timestamp)
}

// map<string, string> status_map = 4;
inline int StatusRecordsResponse::status_map_size() const {
  return status_map_.size();
}
inline void StatusRecordsResponse::clear_status_map() {
  status_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
StatusRecordsResponse::status_map() const {
  // @@protoc_insertion_point(field_map:ecflow_client.StatusRecordsResponse.status_map)
  return status_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
StatusRecordsResponse::mutable_status_map() {
  // @@protoc_insertion_point(field_mutable_map:ecflow_client.StatusRecordsResponse.status_map)
  return status_map_.MutableMap();
}

// -------------------------------------------------------------------

// StatusResponse

// string owner = 1;
inline void StatusResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.owner)
  return owner_.GetNoArena();
}
inline void StatusResponse::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.owner)
}
#if LANG_CXX11
inline void StatusResponse::set_owner(::std::string&& value) {
  
  owner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.owner)
}
#endif
inline void StatusResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.owner)
}
inline void StatusResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.owner)
}
inline ::std::string* StatusResponse::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.owner)
}

// string repo = 2;
inline void StatusResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.repo)
  return repo_.GetNoArena();
}
inline void StatusResponse::set_repo(const ::std::string& value) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.repo)
}
#if LANG_CXX11
inline void StatusResponse::set_repo(::std::string&& value) {
  
  repo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.repo)
}
#endif
inline void StatusResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.repo)
}
inline void StatusResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.repo)
}
inline ::std::string* StatusResponse::mutable_repo() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.repo)
  return repo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.repo)
  
  return repo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_repo(::std::string* repo) {
  if (repo != NULL) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusResponse::clear_collected_timestamp() {
  collected_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StatusResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.collected_timestamp)
  return collected_timestamp_;
}
inline void StatusResponse::set_collected_timestamp(::google::protobuf::int64 value) {
  
  collected_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.collected_timestamp)
}

// string status = 4;
inline void StatusResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.status)
  return status_.GetNoArena();
}
inline void StatusResponse::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.status)
}
#if LANG_CXX11
inline void StatusResponse::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.status)
}
#endif
inline void StatusResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.status)
}
inline void StatusResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.status)
}
inline ::std::string* StatusResponse::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ecflow_client

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
